/*
 * Copyright (c) 2004 DotNetGuru and the individuals listed
 * on the ChangeLog entries.
 *
 * Authors :
 *   Jb Evain   (jb.evain@dotnetguru.org)
 *
 * This is a free software distributed under a MIT/X11 license
 * See LICENSE.MIT file for more details
 *
 * Generated by /CodeGen/cecil-gen.rb do not edit
 * Mon Jan 10 00:16:44 Paris, Madrid 2005
 *
 *****************************************************************************/

namespace Mono.Cecil.Metadata {

    using System;
    using System.Collections;
    using System.IO;

    using Mono.Cecil.Binary;

    internal sealed class MetadataRowReader : IMetadataRowVisitor {

        private MetadataTableReader m_mtrv;
        private BinaryReader m_binaryReader;
        private MetadataRoot m_metadataRoot;
        private IDictionary m_codedIndexCache;

        public MetadataRowReader(MetadataTableReader mtrv) {
            m_mtrv = mtrv;
            m_binaryReader = mtrv.GetReader();
            m_metadataRoot = mtrv.GetMetadataRoot();
            m_codedIndexCache = new Hashtable();
        }

        private int GetIndexSize(Type table) {
            return m_mtrv.GetNumberOfRows(table) < (1 << 16) ? 2 : 4;
        }

        private int GetCodedIndexSize(CodedIndex ci) {
            int bits = 0, max = 0;
            if (m_codedIndexCache[ci] != null) {
                return (int)m_codedIndexCache[ci];
            } else {
                int res = 0;
                ArrayList tables = new ArrayList();
                switch (ci) {
                    case CodedIndex.TypeDefOrRef :
                        bits = 2;
                        tables.Add(typeof(TypeDefTable));
                        tables.Add(typeof(TypeRefTable));
                        tables.Add(typeof(TypeSpecTable));
                        break;
                    case CodedIndex.HasConstant :
                        bits = 2;
                        tables.Add(typeof(FieldTable));
                        tables.Add(typeof(ParamTable));
                        tables.Add(typeof(PropertyTable));
                        break;
                    case CodedIndex.HasCustomAttribute :
                        bits = 5;
                        tables.Add(typeof(MethodTable));
                        tables.Add(typeof(FieldTable));
                        tables.Add(typeof(TypeRefTable));
                        tables.Add(typeof(TypeDefTable));
                        tables.Add(typeof(ParamTable));
                        tables.Add(typeof(InterfaceImplTable));
                        tables.Add(typeof(MemberRefTable));
                        tables.Add(typeof(ModuleTable));
                        tables.Add(typeof(DeclSecurityTable));
                        tables.Add(typeof(PropertyTable));
                        tables.Add(typeof(EventTable));
                        tables.Add(typeof(StandAloneSigTable));
                        tables.Add(typeof(ModuleRefTable));
                        tables.Add(typeof(TypeSpecTable));
                        tables.Add(typeof(AssemblyTable));
                        tables.Add(typeof(AssemblyRefTable));
                        tables.Add(typeof(FileTable));
                        tables.Add(typeof(ExportedTypeTable));
                        tables.Add(typeof(ManifestResourceTable));
                        break;
                    case CodedIndex.HasFieldMarshal :
                        bits = 1;
                        tables.Add(typeof(FieldTable));
                        tables.Add(typeof(ParamTable));
                        break;
                    case CodedIndex.HasDeclSecurity :
                        bits = 2;
                        tables.Add(typeof(TypeDefTable));
                        tables.Add(typeof(MethodTable));
                        tables.Add(typeof(AssemblyTable));
                        break;
                    case CodedIndex.MemberRefParent :
                        bits = 3;
                        tables.Add(typeof(TypeRefTable));
                        tables.Add(typeof(ModuleRefTable));
                        tables.Add(typeof(MethodTable));
                        tables.Add(typeof(TypeSpecTable));
                        break;
                    case CodedIndex.HasSemantics :
                        bits = 1;
                        tables.Add(typeof(EventTable));
                        tables.Add(typeof(PropertyTable));
                        break;
                    case CodedIndex.MethodDefOrRef :
                        bits = 1;
                        tables.Add(typeof(MethodTable));
                        tables.Add(typeof(MemberRefTable));
                        break;
                    case CodedIndex.MemberForwarded :
                        bits = 1;
                        tables.Add(typeof(FieldTable));
                        tables.Add(typeof(MethodTable));
                        break;
                    case CodedIndex.Implementation :
                        bits = 2;
                        tables.Add(typeof(FileTable));
                        tables.Add(typeof(AssemblyRefTable));
                        tables.Add(typeof(ExportedTypeTable));
                        break;
                    case CodedIndex.CustomAttributeType :
                        bits = 3;
                        tables.Add(typeof(MethodTable));
                        tables.Add(typeof(MemberRefTable));
                        break;
                    case CodedIndex.ResolutionScope :
                        bits = 2;
                        tables.Add(typeof(ModuleTable));
                        tables.Add(typeof(ModuleRefTable));
                        tables.Add(typeof(AssemblyRefTable));
                        tables.Add(typeof(TypeRefTable));
                        break;
                }
                foreach (Type t in tables) {
                    int rows = m_mtrv.GetNumberOfRows(t);
                    if (rows > max) max = rows;
                }
                res = max < (1 << (16 - bits)) ? 2 : 4;
                m_codedIndexCache[ci] = res;
                return res;
            }
        }

        private uint ReadByIndexSize(int size) {
            if (size == 2) {
                return (uint)m_binaryReader.ReadUInt16();
            } else if (size == 4) {
                return m_binaryReader.ReadUInt32();
            } else {
                throw new MetadataFormatException("Non valid size for indexing");
            }
        }

        private MetadataToken GetMetadataToken(CodedIndex cidx, uint data) {
            uint rid = 0;
            switch (cidx) {
                case CodedIndex.TypeDefOrRef :
                    rid = data >> 2;
                    switch (data & 3) {
                        case 0 :
                            return new MetadataToken(TokenType.TypeDef, rid);
                        case 1 :
                            return new MetadataToken(TokenType.TypeRef, rid);
                        case 2 :
                            return new MetadataToken(TokenType.TypeSpec, rid);
                        default :
                            throw new MetadataFormatException("Non valid tag for TypeDefOrRef");
                        }
                case CodedIndex.HasConstant :
                    rid = data >> 2;
                    switch (data & 3) {
                        case 0 :
                            return new MetadataToken(TokenType.Field, rid);
                        case 1 :
                            return new MetadataToken(TokenType.Param, rid);
                        case 2 :
                            return new MetadataToken(TokenType.Property, rid);
                        default :
                            throw new MetadataFormatException("Non valid tag for HasConstant");
                        }
                case CodedIndex.HasCustomAttribute :
                    rid = data >> 5;
                    switch (data & 31) {
                        case 0 :
                            return new MetadataToken(TokenType.Method, rid);
                        case 1 :
                            return new MetadataToken(TokenType.Field, rid);
                        case 2 :
                            return new MetadataToken(TokenType.TypeRef, rid);
                        case 3 :
                            return new MetadataToken(TokenType.TypeDef, rid);
                        case 4 :
                            return new MetadataToken(TokenType.Param, rid);
                        case 5 :
                            return new MetadataToken(TokenType.InterfaceImpl, rid);
                        case 6 :
                            return new MetadataToken(TokenType.MemberRef, rid);
                        case 7 :
                            return new MetadataToken(TokenType.Module, rid);
                        case 8 :
                            return new MetadataToken(TokenType.Permission, rid);
                        case 9 :
                            return new MetadataToken(TokenType.Property, rid);
                        case 10 :
                            return new MetadataToken(TokenType.Event, rid);
                        case 11 :
                            return new MetadataToken(TokenType.Signature, rid);
                        case 12 :
                            return new MetadataToken(TokenType.ModuleRef, rid);
                        case 13 :
                            return new MetadataToken(TokenType.TypeSpec, rid);
                        case 14 :
                            return new MetadataToken(TokenType.Assembly, rid);
                        case 15 :
                            return new MetadataToken(TokenType.AssemblyRef, rid);
                        case 16 :
                            return new MetadataToken(TokenType.File, rid);
                        case 17 :
                            return new MetadataToken(TokenType.ExportedType, rid);
                        case 18 :
                            return new MetadataToken(TokenType.ManifestResource, rid);
                        default :
                            throw new MetadataFormatException("Non valid tag for HasCustomAttribute");
                        }
                case CodedIndex.HasFieldMarshal :
                    rid = data >> 1;
                    switch (data & 1) {
                        case 0 :
                            return new MetadataToken(TokenType.Field, rid);
                        case 1 :
                            return new MetadataToken(TokenType.Param, rid);
                        default :
                            throw new MetadataFormatException("Non valid tag for HasFieldMarshal");
                        }
                case CodedIndex.HasDeclSecurity :
                    rid = data >> 2;
                    switch (data & 3) {
                        case 0 :
                            return new MetadataToken(TokenType.TypeDef, rid);
                        case 1 :
                            return new MetadataToken(TokenType.Method, rid);
                        case 2 :
                            return new MetadataToken(TokenType.Assembly, rid);
                        default :
                            throw new MetadataFormatException("Non valid tag for HasDeclSecurity");
                        }
                case CodedIndex.MemberRefParent :
                    rid = data >> 3;
                    switch (data & 7) {
                        case 1 :
                            return new MetadataToken(TokenType.TypeRef, rid);
                        case 2 :
                            return new MetadataToken(TokenType.ModuleRef, rid);
                        case 3 :
                            return new MetadataToken(TokenType.Method, rid);
                        case 4 :
                            return new MetadataToken(TokenType.TypeSpec, rid);
                        default :
                            throw new MetadataFormatException("Non valid tag for MemberRefParent");
                        }
                case CodedIndex.HasSemantics :
                    rid = data >> 1;
                    switch (data & 1) {
                        case 0 :
                            return new MetadataToken(TokenType.Event, rid);
                        case 1 :
                            return new MetadataToken(TokenType.Property, rid);
                        default :
                            throw new MetadataFormatException("Non valid tag for HasSemantics");
                        }
                case CodedIndex.MethodDefOrRef :
                    rid = data >> 1;
                    switch (data & 1) {
                        case 0 :
                            return new MetadataToken(TokenType.Method, rid);
                        case 1 :
                            return new MetadataToken(TokenType.MemberRef, rid);
                        default :
                            throw new MetadataFormatException("Non valid tag for MethodDefOrRef");
                        }
                case CodedIndex.MemberForwarded :
                    rid = data >> 1;
                    switch (data & 1) {
                        case 0 :
                            return new MetadataToken(TokenType.Field, rid);
                        case 1 :
                            return new MetadataToken(TokenType.Method, rid);
                        default :
                            throw new MetadataFormatException("Non valid tag for MemberForwarded");
                        }
                case CodedIndex.Implementation :
                    rid = data >> 2;
                    switch (data & 3) {
                        case 0 :
                            return new MetadataToken(TokenType.File, rid);
                        case 1 :
                            return new MetadataToken(TokenType.AssemblyRef, rid);
                        case 2 :
                            return new MetadataToken(TokenType.ExportedType, rid);
                        default :
                            throw new MetadataFormatException("Non valid tag for Implementation");
                        }
                case CodedIndex.CustomAttributeType :
                    rid = data >> 3;
                    switch (data & 7) {
                        case 2 :
                            return new MetadataToken(TokenType.Method, rid);
                        case 3 :
                            return new MetadataToken(TokenType.MemberRef, rid);
                        default :
                            throw new MetadataFormatException("Non valid tag for CustomAttributeType");
                        }
                case CodedIndex.ResolutionScope :
                    rid = data >> 2;
                    switch (data & 3) {
                        case 0 :
                            return new MetadataToken(TokenType.Module, rid);
                        case 1 :
                            return new MetadataToken(TokenType.ModuleRef, rid);
                        case 2 :
                            return new MetadataToken(TokenType.AssemblyRef, rid);
                        case 3 :
                            return new MetadataToken(TokenType.TypeRef, rid);
                        default :
                            throw new MetadataFormatException("Non valid tag for ResolutionScope");
                        }
            default :
                throw new MetadataFormatException("Non valid CodedIndex");
            }
        }

        public void Visit(RowCollection coll) {}

        public void Visit(AssemblyRow row) {
            row.HashAlgId = (Mono.Cecil.AssemblyHashAlgorithm)m_binaryReader.ReadUInt32();
            row.MajorVersion = m_binaryReader.ReadUInt16();
            row.MinorVersion = m_binaryReader.ReadUInt16();
            row.BuildNumber = m_binaryReader.ReadUInt16();
            row.RevisionNumber = m_binaryReader.ReadUInt16();
            row.Flags = (Mono.Cecil.AssemblyFlags)m_binaryReader.ReadUInt32();
            row.PublicKey = ReadByIndexSize(m_metadataRoot.Streams.BlobHeap.IndexSize);
            row.Name = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.Culture = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
        }

        public void Visit(AssemblyOSRow row) {
            row.OSPlatformID = m_binaryReader.ReadUInt32();
            row.OSMajorVersion = m_binaryReader.ReadUInt32();
            row.OSMinorVersion = m_binaryReader.ReadUInt32();
        }

        public void Visit(AssemblyProcessorRow row) {
            row.Processor = m_binaryReader.ReadUInt32();
        }

        public void Visit(AssemblyRefRow row) {
            row.MajorVersion = m_binaryReader.ReadUInt16();
            row.MinorVersion = m_binaryReader.ReadUInt16();
            row.BuildNumber = m_binaryReader.ReadUInt16();
            row.RevisionNumber = m_binaryReader.ReadUInt16();
            row.Flags = (Mono.Cecil.AssemblyFlags)m_binaryReader.ReadUInt32();
            row.PublicKeyOrToken = ReadByIndexSize(m_metadataRoot.Streams.BlobHeap.IndexSize);
            row.Name = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.Culture = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.HashValue = ReadByIndexSize(m_metadataRoot.Streams.BlobHeap.IndexSize);
        }

        public void Visit(AssemblyRefOSRow row) {
            row.OSPlatformID = m_binaryReader.ReadUInt32();
            row.OSMajorVersion = m_binaryReader.ReadUInt32();
            row.OSMinorVersion = m_binaryReader.ReadUInt32();
            row.AssemblyRef = ReadByIndexSize(GetIndexSize(typeof(AssemblyRefTable)));
        }

        public void Visit(AssemblyRefProcessorRow row) {
            row.Processor = m_binaryReader.ReadUInt32();
            row.AssemblyRef = ReadByIndexSize(GetIndexSize(typeof(AssemblyRefTable)));
        }

        public void Visit(ClassLayoutRow row) {
            row.PackingSize = m_binaryReader.ReadUInt16();
            row.ClassSize = m_binaryReader.ReadUInt32();
            row.Parent = ReadByIndexSize(GetIndexSize(typeof(TypeDefTable)));
        }

        public void Visit(ConstantRow row) {
            row.Type = (Mono.Cecil.Metadata.ElementType)m_binaryReader.ReadUInt16();
            row.Parent = GetMetadataToken(CodedIndex.HasConstant,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.HasConstant)));
            row.Value = ReadByIndexSize(m_metadataRoot.Streams.BlobHeap.IndexSize);
        }

        public void Visit(CustomAttributeRow row) {
            row.Parent = GetMetadataToken(CodedIndex.HasCustomAttribute,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.HasCustomAttribute)));
            row.Type = GetMetadataToken(CodedIndex.CustomAttributeType,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.CustomAttributeType)));
            row.Value = ReadByIndexSize(m_metadataRoot.Streams.BlobHeap.IndexSize);
        }

        public void Visit(DeclSecurityRow row) {
            row.Action = m_binaryReader.ReadInt16();
            row.Parent = GetMetadataToken(CodedIndex.HasDeclSecurity,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.HasDeclSecurity)));
            row.PermissionSet = ReadByIndexSize(m_metadataRoot.Streams.BlobHeap.IndexSize);
        }

        public void Visit(EventMapRow row) {
            row.Parent = ReadByIndexSize(GetIndexSize(typeof(TypeDefTable)));
            row.EventList = ReadByIndexSize(GetIndexSize(typeof(EventTable)));
        }

        public void Visit(EventRow row) {
            row.EventFlags = (Mono.Cecil.EventAttributes)m_binaryReader.ReadUInt16();
            row.Name = m_binaryReader.ReadUInt32();
            row.EventType = GetMetadataToken(CodedIndex.TypeDefOrRef,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.TypeDefOrRef)));
        }

        public void Visit(ExportedTypeRow row) {
            row.Flags = (Mono.Cecil.TypeAttributes)m_binaryReader.ReadUInt32();
            row.TypeDefId = m_binaryReader.ReadUInt32();
            row.TypeName = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.TypeNamespace = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.Implementation = GetMetadataToken(CodedIndex.Implementation,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.Implementation)));
        }

        public void Visit(FieldRow row) {
            row.Flags = (Mono.Cecil.FieldAttributes)m_binaryReader.ReadUInt16();
            row.Name = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.Signature = ReadByIndexSize(m_metadataRoot.Streams.BlobHeap.IndexSize);
        }

        public void Visit(FieldLayoutRow row) {
            row.Offset = m_binaryReader.ReadUInt32();
            row.Field = ReadByIndexSize(GetIndexSize(typeof(FieldTable)));
        }

        public void Visit(FieldMarshalRow row) {
            row.Parent = GetMetadataToken(CodedIndex.HasFieldMarshal,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.HasFieldMarshal)));
            row.NativeType = ReadByIndexSize(m_metadataRoot.Streams.BlobHeap.IndexSize);
        }

        public void Visit(FieldRVARow row) {
            row.RVA = new RVA(m_binaryReader.ReadUInt32());
            row.Field = ReadByIndexSize(GetIndexSize(typeof(FieldTable)));
        }

        public void Visit(FileRow row) {
            row.Flags = (Mono.Cecil.FileAttributes)m_binaryReader.ReadUInt32();
            row.Name = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.HashValue = ReadByIndexSize(m_metadataRoot.Streams.BlobHeap.IndexSize);
        }

        public void Visit(ImplMapRow row) {
            row.MappingFlags = (Mono.Cecil.PInvokeAttributes)m_binaryReader.ReadUInt16();
            row.MemberForwarded = GetMetadataToken(CodedIndex.MemberForwarded,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.MemberForwarded)));
            row.ImportName = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.ImportScope = ReadByIndexSize(GetIndexSize(typeof(ModuleRefTable)));
        }

        public void Visit(InterfaceImplRow row) {
            row.Class = ReadByIndexSize(GetIndexSize(typeof(TypeDefTable)));
            row.Interface = GetMetadataToken(CodedIndex.TypeDefOrRef,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.TypeDefOrRef)));
        }

        public void Visit(ManifestResourceRow row) {
            row.Offset = m_binaryReader.ReadUInt32();
            row.Flags = (Mono.Cecil.ManifestResourceAttributes)m_binaryReader.ReadUInt32();
            row.Name = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.Implementation = GetMetadataToken(CodedIndex.Implementation,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.Implementation)));
        }

        public void Visit(MemberRefRow row) {
            row.Class = GetMetadataToken(CodedIndex.MemberRefParent,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.MemberRefParent)));
            row.Name = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.Signature = ReadByIndexSize(m_metadataRoot.Streams.BlobHeap.IndexSize);
        }

        public void Visit(MethodRow row) {
            row.RVA = new RVA(m_binaryReader.ReadUInt32());
            row.ImplFlags = (Mono.Cecil.MethodImplAttributes)m_binaryReader.ReadUInt16();
            row.Flags = (Mono.Cecil.MethodAttributes)m_binaryReader.ReadUInt16();
            row.Name = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.Signature = ReadByIndexSize(m_metadataRoot.Streams.BlobHeap.IndexSize);
            row.ParamList = ReadByIndexSize(GetIndexSize(typeof(ParamTable)));
        }

        public void Visit(MethodImplRow row) {
            row.Class = ReadByIndexSize(GetIndexSize(typeof(TypeDefTable)));
            row.MethodBody = GetMetadataToken(CodedIndex.MethodDefOrRef,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.MethodDefOrRef)));
            row.MethodDeclaration = GetMetadataToken(CodedIndex.MethodDefOrRef,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.MethodDefOrRef)));
        }

        public void Visit(MethodSemanticsRow row) {
            row.Semantics = (Mono.Cecil.MethodSemanticsAttributes)m_binaryReader.ReadUInt16();
            row.Method = ReadByIndexSize(GetIndexSize(typeof(MethodTable)));
            row.Association = GetMetadataToken(CodedIndex.HasSemantics,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.HasSemantics)));
        }

        public void Visit(ModuleRow row) {
            row.Generation = m_binaryReader.ReadUInt16();
            row.Name = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.Mvid = ReadByIndexSize(m_metadataRoot.Streams.GuidHeap.IndexSize);
            row.EncId = ReadByIndexSize(m_metadataRoot.Streams.GuidHeap.IndexSize);
            row.EncBaseId = ReadByIndexSize(m_metadataRoot.Streams.GuidHeap.IndexSize);
        }

        public void Visit(ModuleRefRow row) {
            row.Name = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
        }

        public void Visit(NestedClassRow row) {
            row.NestedClass = ReadByIndexSize(GetIndexSize(typeof(TypeDefTable)));
            row.EnclosingClass = ReadByIndexSize(GetIndexSize(typeof(TypeDefTable)));
        }

        public void Visit(ParamRow row) {
            row.Flags = (Mono.Cecil.ParamAttributes)m_binaryReader.ReadUInt16();
            row.Sequence = m_binaryReader.ReadUInt16();
            row.Name = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
        }

        public void Visit(PropertyRow row) {
            row.Flags = (Mono.Cecil.PropertyAttributes)m_binaryReader.ReadUInt16();
            row.Name = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.Type = ReadByIndexSize(m_metadataRoot.Streams.BlobHeap.IndexSize);
        }

        public void Visit(PropertyMapRow row) {
            row.Parent = ReadByIndexSize(GetIndexSize(typeof(TypeDefTable)));
            row.PropertyList = ReadByIndexSize(GetIndexSize(typeof(PropertyTable)));
        }

        public void Visit(StandAloneSigRow row) {
            row.Signature = ReadByIndexSize(m_metadataRoot.Streams.BlobHeap.IndexSize);
        }

        public void Visit(TypeDefRow row) {
            row.Flags = (Mono.Cecil.TypeAttributes)m_binaryReader.ReadUInt32();
            row.Name = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.Namespace = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.Extends = GetMetadataToken(CodedIndex.TypeDefOrRef,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.TypeDefOrRef)));
            row.FieldList = ReadByIndexSize(GetIndexSize(typeof(FieldTable)));
            row.MethodList = ReadByIndexSize(GetIndexSize(typeof(MethodTable)));
        }

        public void Visit(TypeRefRow row) {
            row.ResolutionScope = GetMetadataToken(CodedIndex.ResolutionScope,
                ReadByIndexSize(GetCodedIndexSize(CodedIndex.ResolutionScope)));
            row.Name = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
            row.Namespace = ReadByIndexSize(m_metadataRoot.Streams.StringsHeap.IndexSize);
        }

        public void Visit(TypeSpecRow row) {
            row.Signature = ReadByIndexSize(m_metadataRoot.Streams.BlobHeap.IndexSize);
        }

        public void Terminate(RowCollection coll) {}
    }
}
